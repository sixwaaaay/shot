/* tslint:disable */
/* eslint-disable */
/**
 * sharing
 * Sharing has a really interesting name
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 *
 * @export
 * @interface Comment
 */
export interface Comment {
    /**
     *
     * @type {string}
     * @memberof Comment
     */
    id?: string;
    /**
     *
     * @type {string}
     * @memberof Comment
     */
    content?: string;
    /**
     *
     * @type {string}
     * @memberof Comment
     */
    create_at?: string;
    /**
     *
     * @type {User}
     * @memberof Comment
     */
    user?: User;
}

/**
 *
 * @export
 * @interface CommentActionReply
 */
export interface CommentActionReply {
    /**
     *
     * @type {Comment}
     * @memberof CommentActionReply
     */
    comment?: Comment;
}

/**
 *
 * @export
 * @interface CommentActionReq
 */
export interface CommentActionReq {
    /**
     *
     * @type {string}
     * @memberof CommentActionReq
     */
    video_id: string;
    /**
     *
     * @type {number}
     * @memberof CommentActionReq
     */
    action: number;
    /**
     *
     * @type {string}
     * @memberof CommentActionReq
     */
    comment_text?: string;
    /**
     *
     * @type {string}
     * @memberof CommentActionReq
     */
    comment_id?: string;
}

/**
 *
 * @export
 * @interface CommentListReply
 */
export interface CommentListReply {
    /**
     *
     * @type {Array<Comment>}
     * @memberof CommentListReply
     */
    comment_list?: Array<Comment>;
}

/**
 *
 * @export
 * @interface CommentListReq
 */
export interface CommentListReq {
    /**
     *
     * @type {string}
     * @memberof CommentListReq
     */
    video_id: string;
    /**
     *
     * @type {string}
     * @memberof CommentListReq
     */
    token?: string;
    /**
     *
     * @type {number}
     * @memberof CommentListReq
     */
    limit?: number;
}

/**
 *
 * @export
 * @interface FollowActionRequest
 */
export interface FollowActionRequest {
    /**
     *
     * @type {string}
     * @memberof FollowActionRequest
     */
    user_id: string;
    /**
     *
     * @type {number}
     * @memberof FollowActionRequest
     */
    action: number;
}

/**
 *
 * @export
 * @interface GetFollowersReply
 */
export interface GetFollowersReply {
    /**
     *
     * @type {Array<User>}
     * @memberof GetFollowersReply
     */
    users?: Array<User>;
}

/**
 *
 * @export
 * @interface GetFollowersRequest
 */
export interface GetFollowersRequest {
    /**
     *
     * @type {string}
     * @memberof GetFollowersRequest
     */
    user_id: string;
    /**
     *
     * @type {number}
     * @memberof GetFollowersRequest
     */
    limit?: number;
    /**
     *
     * @type {string}
     * @memberof GetFollowersRequest
     */
    token?: string;
}

/**
 *
 * @export
 * @interface GetFollowingsReply
 */
export interface GetFollowingsReply {
    /**
     *
     * @type {Array<User>}
     * @memberof GetFollowingsReply
     */
    users?: Array<User>;
}

/**
 *
 * @export
 * @interface GetFollowingsRequest
 */
export interface GetFollowingsRequest {
    /**
     *
     * @type {string}
     * @memberof GetFollowingsRequest
     */
    user_id: string;
    /**
     *
     * @type {number}
     * @memberof GetFollowingsRequest
     */
    limit: number;
    /**
     *
     * @type {string}
     * @memberof GetFollowingsRequest
     */
    token: string;
}

/**
 *
 * @export
 * @interface GetFriendsReply
 */
export interface GetFriendsReply {
    /**
     *
     * @type {Array<User>}
     * @memberof GetFriendsReply
     */
    users?: Array<User>;
}

/**
 *
 * @export
 * @interface GetFriendsRequest
 */
export interface GetFriendsRequest {
    /**
     *
     * @type {number}
     * @memberof GetFriendsRequest
     */
    limit: number;
    /**
     *
     * @type {string}
     * @memberof GetFriendsRequest
     */
    token: string;
}

/**
 *
 * @export
 * @interface GetLikedVideosReply
 */
export interface GetLikedVideosReply {
    /**
     *
     * @type {Array<Video>}
     * @memberof GetLikedVideosReply
     */
    videos?: Array<Video>;
}

/**
 *
 * @export
 * @interface GetLikedVideosRequest
 */
export interface GetLikedVideosRequest {
    /**
     *
     * @type {string}
     * @memberof GetLikedVideosRequest
     */
    user_id: string;
    /**
     *
     * @type {number}
     * @memberof GetLikedVideosRequest
     */
    limit?: number;
    /**
     *
     * @type {string}
     * @memberof GetLikedVideosRequest
     */
    token?: string;
}

/**
 *
 * @export
 * @interface GetMessagesReply
 */
export interface GetMessagesReply {
    /**
     *
     * @type {Array<Message>}
     * @memberof GetMessagesReply
     */
    message_list?: Array<Message>;
}

/**
 *
 * @export
 * @interface GetMessagesRequest
 */
export interface GetMessagesRequest {
    /**
     *
     * @type {string}
     * @memberof GetMessagesRequest
     */
    to_user_id?: string;
    /**
     *
     * @type {string}
     * @memberof GetMessagesRequest
     */
    token?: string;
}

/**
 *
 * @export
 * @interface GetRecentVideosReply
 */
export interface GetRecentVideosReply {
    /**
     *
     * @type {Array<Video>}
     * @memberof GetRecentVideosReply
     */
    videos?: Array<Video>;
}

/**
 *
 * @export
 * @interface GetRecentVideosRequest
 */
export interface GetRecentVideosRequest {
    /**
     *
     * @type {number}
     * @memberof GetRecentVideosRequest
     */
    limit?: number;
    /**
     *
     * @type {string}
     * @memberof GetRecentVideosRequest
     */
    token?: string;
}

/**
 *
 * @export
 * @interface GetUserVideosReply
 */
export interface GetUserVideosReply {
    /**
     *
     * @type {Array<Video>}
     * @memberof GetUserVideosReply
     */
    videos?: Array<Video>;
}

/**
 *
 * @export
 * @interface GetUserVideosRequest
 */
export interface GetUserVideosRequest {
    /**
     *
     * @type {string}
     * @memberof GetUserVideosRequest
     */
    user_id: string;
    /**
     *
     * @type {number}
     * @memberof GetUserVideosRequest
     */
    limit?: number;
    /**
     *
     * @type {string}
     * @memberof GetUserVideosRequest
     */
    token?: string;
}

/**
 *
 * @export
 * @interface GetVideoReply
 */
export interface GetVideoReply {
    /**
     *
     * @type {Video}
     * @memberof GetVideoReply
     */
    video?: Video;
}

/**
 *
 * @export
 * @interface LikeVideoRequest
 */
export interface LikeVideoRequest {
    /**
     *
     * @type {string}
     * @memberof LikeVideoRequest
     */
    video_id: string;
    /**
     *
     * @type {number}
     * @memberof LikeVideoRequest
     */
    action: number;
}

/**
 *
 * @export
 * @interface LoginReply
 */
export interface LoginReply {
    /**
     *
     * @type {User}
     * @memberof LoginReply
     */
    account?: User;
    /**
     *
     * @type {string}
     * @memberof LoginReply
     */
    token?: string;
}

/**
 *
 * @export
 * @interface LoginRequest
 */
export interface LoginRequest {
    /**
     *
     * @type {string}
     * @memberof LoginRequest
     */
    email: string;
    /**
     *
     * @type {string}
     * @memberof LoginRequest
     */
    password: string;
}

/**
 *
 * @export
 * @interface Message
 */
export interface Message {
    /**
     *
     * @type {string}
     * @memberof Message
     */
    id: string;
    /**
     *
     * @type {string}
     * @memberof Message
     */
    to_user_id: string;
    /**
     *
     * @type {string}
     * @memberof Message
     */
    from_user_id: string;
    /**
     *
     * @type {string}
     * @memberof Message
     */
    content: string;
    /**
     *
     * @type {string}
     * @memberof Message
     */
    create_time: string;
}

/**
 *
 * @export
 * @interface RegisterReply
 */
export interface RegisterReply {
    /**
     *
     * @type {User}
     * @memberof RegisterReply
     */
    account?: User;
    /**
     *
     * @type {string}
     * @memberof RegisterReply
     */
    token?: string;
}

/**
 *
 * @export
 * @interface RegisterRequest
 */
export interface RegisterRequest {
    /**
     *
     * @type {string}
     * @memberof RegisterRequest
     */
    email: string;
    /**
     *
     * @type {string}
     * @memberof RegisterRequest
     */
    password: string;
    /**
     *
     * @type {string}
     * @memberof RegisterRequest
     */
    name: string;
}

/**
 *
 * @export
 * @interface SendMessageRequest
 */
export interface SendMessageRequest {
    /**
     *
     * @type {string}
     * @memberof SendMessageRequest
     */
    to_user_id: string;
    /**
     *
     * @type {string}
     * @memberof SendMessageRequest
     */
    content: string;
    /**
     *
     * @type {number}
     * @memberof SendMessageRequest
     */
    action_type: number;
}

/**
 *
 * @export
 * @interface UpdateProfileResponse
 */
export interface UpdateProfileResponse {
    /**
     *
     * @type {User}
     * @memberof UpdateProfileResponse
     */
    profile?: User;
}

/**
 *
 * @export
 * @interface User
 */
export interface User {
    /**
     *
     * @type {string}
     * @memberof User
     */
    id: string;
    /**
     *
     * @type {string}
     * @memberof User
     */
    name: string;
    /**
     *
     * @type {boolean}
     * @memberof User
     */
    is_follow?: boolean;
    /**
     *
     * @type {string}
     * @memberof User
     */
    avatar_url?: string;
    /**
     *
     * @type {string}
     * @memberof User
     */
    bg_url?: string;
    /**
     *
     * @type {string}
     * @memberof User
     */
    bio?: string;
    /**
     *
     * @type {number}
     * @memberof User
     */
    likes_given?: number;
    /**
     *
     * @type {number}
     * @memberof User
     */
    likes_received?: number;
    /**
     *
     * @type {number}
     * @memberof User
     */
    videos_posted?: number;
    /**
     *
     * @type {number}
     * @memberof User
     */
    following?: number;
    /**
     *
     * @type {number}
     * @memberof User
     */
    followers?: number;
}

/**
 *
 * @export
 * @interface Video
 */
export interface Video {
    /**
     *
     * @type {string}
     * @memberof Video
     */
    id: string;
    /**
     *
     * @type {User}
     * @memberof Video
     */
    author?: User;
    /**
     *
     * @type {string}
     * @memberof Video
     */
    title?: string;
    /**
     *
     * @type {string}
     * @memberof Video
     */
    description?: string;
    /**
     *
     * @type {string}
     * @memberof Video
     */
    cover_url?: string;
    /**
     *
     * @type {string}
     * @memberof Video
     */
    video_url?: string;
    /**
     *
     * @type {boolean}
     * @memberof Video
     */
    is_liked?: boolean;
    /**
     *
     * @type {string}
     * @memberof Video
     */
    upload_time?: string;
    /**
     *
     * @type {number}
     * @memberof Video
     */
    duration?: number;
}

/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary Create a comment
         * @param {string} authorization Bearer token for authentication
         * @param {CommentActionReq} commentActionReq Comment information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createComment: async (authorization: string, commentActionReq: CommentActionReq, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            if (authorization === null || authorization === undefined) {
                throw new RequiredError('authorization', 'Required parameter authorization was null or undefined when calling createComment.');
            }
            // verify required parameter 'commentActionReq' is not null or undefined
            if (commentActionReq === null || commentActionReq === undefined) {
                throw new RequiredError('commentActionReq', 'Required parameter commentActionReq was null or undefined when calling createComment.');
            }
            const localVarPath = `/comments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof commentActionReq !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(commentActionReq !== undefined ? commentActionReq : {})
                : (commentActionReq || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Follow or unfollow a user
         * @param {string} authorization Bearer token for authentication
         * @param {FollowActionRequest} followActionRequest User ID and action to perform
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        followAction: async (authorization: string, followActionRequest: FollowActionRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            if (authorization === null || authorization === undefined) {
                throw new RequiredError('authorization', 'Required parameter authorization was null or undefined when calling followAction.');
            }
            // verify required parameter 'followActionRequest' is not null or undefined
            if (followActionRequest === null || followActionRequest === undefined) {
                throw new RequiredError('followActionRequest', 'Required parameter followActionRequest was null or undefined when calling followAction.');
            }
            const localVarPath = `/follow`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof followActionRequest !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(followActionRequest !== undefined ? followActionRequest : {})
                : (followActionRequest || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get comments for a video
         * @param {CommentListReq} commentListReq Comment information
         * @param {string} [authorization] Bearer token for authentication
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getComments: async (commentListReq: CommentListReq, authorization?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'commentListReq' is not null or undefined
            if (commentListReq === null || commentListReq === undefined) {
                throw new RequiredError('commentListReq', 'Required parameter commentListReq was null or undefined when calling getComments.');
            }
            const localVarPath = `/comments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof commentListReq !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(commentListReq !== undefined ? commentListReq : {})
                : (commentListReq || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get followers of a user
         * @param {GetFollowersRequest} getFollowersRequest User ID and action to perform
         * @param {string} [authorization] Bearer token for authentication
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFollowers: async (getFollowersRequest: GetFollowersRequest, authorization?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'getFollowersRequest' is not null or undefined
            if (getFollowersRequest === null || getFollowersRequest === undefined) {
                throw new RequiredError('getFollowersRequest', 'Required parameter getFollowersRequest was null or undefined when calling getFollowers.');
            }
            const localVarPath = `/follow/followers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof getFollowersRequest !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(getFollowersRequest !== undefined ? getFollowersRequest : {})
                : (getFollowersRequest || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get users followed by a user
         * @param {GetFollowingsRequest} getFollowingsRequest User ID and action to perform
         * @param {string} [authorization] Bearer token for authentication
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFollowing: async (getFollowingsRequest: GetFollowingsRequest, authorization?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'getFollowingsRequest' is not null or undefined
            if (getFollowingsRequest === null || getFollowingsRequest === undefined) {
                throw new RequiredError('getFollowingsRequest', 'Required parameter getFollowingsRequest was null or undefined when calling getFollowing.');
            }
            const localVarPath = `/follow/following`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof getFollowingsRequest !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(getFollowingsRequest !== undefined ? getFollowingsRequest : {})
                : (getFollowingsRequest || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get friends of a user
         * @param {string} authorization Bearer token for authentication
         * @param {GetFriendsRequest} getFriendsRequest User ID and action to perform
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFriends: async (authorization: string, getFriendsRequest: GetFriendsRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            if (authorization === null || authorization === undefined) {
                throw new RequiredError('authorization', 'Required parameter authorization was null or undefined when calling getFriends.');
            }
            // verify required parameter 'getFriendsRequest' is not null or undefined
            if (getFriendsRequest === null || getFriendsRequest === undefined) {
                throw new RequiredError('getFriendsRequest', 'Required parameter getFriendsRequest was null or undefined when calling getFriends.');
            }
            const localVarPath = `/follow/friends`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof getFriendsRequest !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(getFriendsRequest !== undefined ? getFriendsRequest : {})
                : (getFriendsRequest || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get liked videos by user ID
         * @param {GetLikedVideosRequest} getLikedVideosRequest User ID and action to perform
         * @param {string} [authorization] Bearer token for authentication
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLikedVideos: async (getLikedVideosRequest: GetLikedVideosRequest, authorization?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'getLikedVideosRequest' is not null or undefined
            if (getLikedVideosRequest === null || getLikedVideosRequest === undefined) {
                throw new RequiredError('getLikedVideosRequest', 'Required parameter getLikedVideosRequest was null or undefined when calling getLikedVideos.');
            }
            const localVarPath = `/videos/liked`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof getLikedVideosRequest !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(getLikedVideosRequest !== undefined ? getLikedVideosRequest : {})
                : (getLikedVideosRequest || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get messages
         * @param {string} authorization Bearer token for authentication
         * @param {GetMessagesRequest} getMessagesRequest Message information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessages: async (authorization: string, getMessagesRequest: GetMessagesRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            if (authorization === null || authorization === undefined) {
                throw new RequiredError('authorization', 'Required parameter authorization was null or undefined when calling getMessages.');
            }
            // verify required parameter 'getMessagesRequest' is not null or undefined
            if (getMessagesRequest === null || getMessagesRequest === undefined) {
                throw new RequiredError('getMessagesRequest', 'Required parameter getMessagesRequest was null or undefined when calling getMessages.');
            }
            const localVarPath = `/messages`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof getMessagesRequest !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(getMessagesRequest !== undefined ? getMessagesRequest : {})
                : (getMessagesRequest || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get recent videos by user ID
         * @param {GetRecentVideosRequest} getRecentVideosRequest User ID and action to perform
         * @param {string} [authorization] Bearer token for authentication
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecentVideos: async (getRecentVideosRequest: GetRecentVideosRequest, authorization?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'getRecentVideosRequest' is not null or undefined
            if (getRecentVideosRequest === null || getRecentVideosRequest === undefined) {
                throw new RequiredError('getRecentVideosRequest', 'Required parameter getRecentVideosRequest was null or undefined when calling getRecentVideos.');
            }
            const localVarPath = `/videos/recent`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof getRecentVideosRequest !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(getRecentVideosRequest !== undefined ? getRecentVideosRequest : {})
                : (getRecentVideosRequest || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get user by ID
         * @param {string} userId ID of the user to retrieve
         * @param {string} authorization Bearer token for authentication
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser: async (userId: string, authorization: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId', 'Required parameter userId was null or undefined when calling getUser.');
            }
            // verify required parameter 'authorization' is not null or undefined
            if (authorization === null || authorization === undefined) {
                throw new RequiredError('authorization', 'Required parameter authorization was null or undefined when calling getUser.');
            }
            const localVarPath = `/users/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get videos by user ID
         * @param {GetUserVideosRequest} getUserVideosRequest User ID and action to perform
         * @param {string} [authorization] Bearer token for authentication
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserVideos: async (getUserVideosRequest: GetUserVideosRequest, authorization?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'getUserVideosRequest' is not null or undefined
            if (getUserVideosRequest === null || getUserVideosRequest === undefined) {
                throw new RequiredError('getUserVideosRequest','Required parameter getUserVideosRequest was null or undefined when calling getUserVideos.');
            }
            const localVarPath = `/videos/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof getUserVideosRequest !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(getUserVideosRequest !== undefined ? getUserVideosRequest : {})
                : (getUserVideosRequest || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get video by ID
         * @param {string} videoId ID of the video to retrieve
         * @param {string} [authorization] Bearer token for authentication
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVideo: async (videoId: string, authorization?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'videoId' is not null or undefined
            if (videoId === null || videoId === undefined) {
                throw new RequiredError('videoId', 'Required parameter videoId was null or undefined when calling getVideo.');
            }
            const localVarPath = `/videos/{video_id}`
                .replace(`{${"video_id"}}`, encodeURIComponent(String(videoId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Like a video
         * @param {string} authorization Bearer token for authentication
         * @param {LikeVideoRequest} likeVideoRequest Video ID and action to perform
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        likeVideo: async (authorization: string, likeVideoRequest: LikeVideoRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            if (authorization === null || authorization === undefined) {
                throw new RequiredError('authorization', 'Required parameter authorization was null or undefined when calling likeVideo.');
            }
            // verify required parameter 'likeVideoRequest' is not null or undefined
            if (likeVideoRequest === null || likeVideoRequest === undefined) {
                throw new RequiredError('likeVideoRequest', 'Required parameter likeVideoRequest was null or undefined when calling likeVideo.');
            }
            const localVarPath = `/videos/liked`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof likeVideoRequest !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(likeVideoRequest !== undefined ? likeVideoRequest : {})
                : (likeVideoRequest || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Authenticate user and login
         * @param {LoginRequest} loginRequest User credentials
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login: async (loginRequest: LoginRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'loginRequest' is not null or undefined
            if (loginRequest === null || loginRequest === undefined) {
                throw new RequiredError('loginRequest', 'Required parameter loginRequest was null or undefined when calling login.');
            }
            const localVarPath = `/sign/in`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof loginRequest !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(loginRequest !== undefined ? loginRequest : {})
                : (loginRequest || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Register a new user
         * @param {RegisterRequest} registerRequest User information for registration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        register: async (registerRequest: RegisterRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'registerRequest' is not null or undefined
            if (registerRequest === null || registerRequest === undefined) {
                throw new RequiredError('registerRequest', 'Required parameter registerRequest was null or undefined when calling register.');
            }
            const localVarPath = `/sign/up`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof registerRequest !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(registerRequest !== undefined ? registerRequest : {})
                : (registerRequest || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Send a message
         * @param {string} authorization Bearer token for authentication
         * @param {SendMessageRequest} sendMessageRequest Message information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendMessage: async (authorization: string, sendMessageRequest: SendMessageRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            if (authorization === null || authorization === undefined) {
                throw new RequiredError('authorization', 'Required parameter authorization was null or undefined when calling sendMessage.');
            }
            // verify required parameter 'sendMessageRequest' is not null or undefined
            if (sendMessageRequest === null || sendMessageRequest === undefined) {
                throw new RequiredError('sendMessageRequest', 'Required parameter sendMessageRequest was null or undefined when calling sendMessage.');
            }
            const localVarPath = `/messages`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof sendMessageRequest !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(sendMessageRequest !== undefined ? sendMessageRequest : {})
                : (sendMessageRequest || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Update user profile
         * @param {string} authorization Bearer token for authentication
         * @param {string} [name]
         * @param {string} [bio]
         * @param {any} [avatar]
         * @param {any} [bg]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProfile: async (authorization: string, name?: string, bio?: string, avatar?: any, bg?: any, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            if (authorization === null || authorization === undefined) {
                throw new RequiredError('authorization', 'Required parameter authorization was null or undefined when calling updateProfile.');
            }
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


            if (name !== undefined) {
                localVarFormParams.append('name', name as any);
            }

            if (bio !== undefined) {
                localVarFormParams.append('bio', bio as any);
            }

            if (avatar !== undefined) {
                localVarFormParams.append('avatar', avatar as any);
            }

            if (bg !== undefined) {
                localVarFormParams.append('bg', bg as any);
            }


            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Upload a video
         * @param {string} authorization Bearer token for authentication
         * @param {string} [title]
         * @param {string} [description]
         * @param {string} [category]
         * @param {any} [video]
         * @param {any} [cover]
         * @param {Array<string>} [tags]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadVideo: async (authorization: string, title?: string, description?: string, category?: string, video?: any, cover?: any, tags?: Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            if (authorization === null || authorization === undefined) {
                throw new RequiredError('authorization', 'Required parameter authorization was null or undefined when calling uploadVideo.');
            }
            const localVarPath = `/videos`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


            if (title !== undefined) {
                localVarFormParams.append('title', title as any);
            }

            if (description !== undefined) {
                localVarFormParams.append('description', description as any);
            }

            if (category !== undefined) {
                localVarFormParams.append('category', category as any);
            }

            if (video !== undefined) {
                localVarFormParams.append('video', video as any);
            }

            if (cover !== undefined) {
                localVarFormParams.append('cover', cover as any);
            }
            if (tags) {
                localVarFormParams.append(tags.join(COLLECTION_FORMATS.csv));
            }


            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary Create a comment
         * @param {string} authorization Bearer token for authentication
         * @param {CommentActionReq} commentActionReq Comment information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createComment(authorization: string, commentActionReq: CommentActionReq, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CommentActionReply>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).createComment(authorization, commentActionReq, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {
                    ...localVarAxiosArgs.options,
                    url: (configuration?.basePath || basePath) + localVarAxiosArgs.url
                };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Follow or unfollow a user
         * @param {string} authorization Bearer token for authentication
         * @param {FollowActionRequest} followActionRequest User ID and action to perform
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async followAction(authorization: string, followActionRequest: FollowActionRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).followAction(authorization, followActionRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {
                    ...localVarAxiosArgs.options,
                    url: (configuration?.basePath || basePath) + localVarAxiosArgs.url
                };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Get comments for a video
         * @param {CommentListReq} commentListReq Comment information
         * @param {string} [authorization] Bearer token for authentication
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getComments(commentListReq: CommentListReq, authorization?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CommentListReply>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).getComments(commentListReq, authorization, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {
                    ...localVarAxiosArgs.options,
                    url: (configuration?.basePath || basePath) + localVarAxiosArgs.url
                };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Get followers of a user
         * @param {GetFollowersRequest} getFollowersRequest User ID and action to perform
         * @param {string} [authorization] Bearer token for authentication
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFollowers(getFollowersRequest: GetFollowersRequest, authorization?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetFollowersReply>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).getFollowers(getFollowersRequest, authorization, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {
                    ...localVarAxiosArgs.options,
                    url: (configuration?.basePath || basePath) + localVarAxiosArgs.url
                };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Get users followed by a user
         * @param {GetFollowingsRequest} getFollowingsRequest User ID and action to perform
         * @param {string} [authorization] Bearer token for authentication
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFollowing(getFollowingsRequest: GetFollowingsRequest, authorization?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetFollowingsReply>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).getFollowing(getFollowingsRequest, authorization, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {
                    ...localVarAxiosArgs.options,
                    url: (configuration?.basePath || basePath) + localVarAxiosArgs.url
                };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Get friends of a user
         * @param {string} authorization Bearer token for authentication
         * @param {GetFriendsRequest} getFriendsRequest User ID and action to perform
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFriends(authorization: string, getFriendsRequest: GetFriendsRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetFriendsReply>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).getFriends(authorization, getFriendsRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {
                    ...localVarAxiosArgs.options,
                    url: (configuration?.basePath || basePath) + localVarAxiosArgs.url
                };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Get liked videos by user ID
         * @param {GetLikedVideosRequest} getLikedVideosRequest User ID and action to perform
         * @param {string} [authorization] Bearer token for authentication
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLikedVideos(getLikedVideosRequest: GetLikedVideosRequest, authorization?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetLikedVideosReply>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).getLikedVideos(getLikedVideosRequest, authorization, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {
                    ...localVarAxiosArgs.options,
                    url: (configuration?.basePath || basePath) + localVarAxiosArgs.url
                };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Get messages
         * @param {string} authorization Bearer token for authentication
         * @param {GetMessagesRequest} getMessagesRequest Message information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMessages(authorization: string, getMessagesRequest: GetMessagesRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMessagesReply>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).getMessages(authorization, getMessagesRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {
                    ...localVarAxiosArgs.options,
                    url: (configuration?.basePath || basePath) + localVarAxiosArgs.url
                };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Get recent videos by user ID
         * @param {GetRecentVideosRequest} getRecentVideosRequest User ID and action to perform
         * @param {string} [authorization] Bearer token for authentication
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRecentVideos(getRecentVideosRequest: GetRecentVideosRequest, authorization?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetRecentVideosReply>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).getRecentVideos(getRecentVideosRequest, authorization, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {
                    ...localVarAxiosArgs.options,
                    url: (configuration?.basePath || basePath) + localVarAxiosArgs.url
                };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Get user by ID
         * @param {string} userId ID of the user to retrieve
         * @param {string} authorization Bearer token for authentication
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUser(userId: string, authorization: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).getUser(userId, authorization, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {
                    ...localVarAxiosArgs.options,
                    url: (configuration?.basePath || basePath) + localVarAxiosArgs.url
                };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Get videos by user ID
         * @param {GetUserVideosRequest} getUserVideosRequest User ID and action to perform
         * @param {string} [authorization] Bearer token for authentication
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserVideos(getUserVideosRequest: GetUserVideosRequest, authorization?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUserVideosReply>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).getUserVideos(getUserVideosRequest, authorization, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {
                    ...localVarAxiosArgs.options,
                    url: (configuration?.basePath || basePath) + localVarAxiosArgs.url
                };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Get video by ID
         * @param {string} videoId ID of the video to retrieve
         * @param {string} [authorization] Bearer token for authentication
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVideo(videoId: string, authorization?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetVideoReply>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).getVideo(videoId, authorization, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {
                    ...localVarAxiosArgs.options,
                    url: (configuration?.basePath || basePath) + localVarAxiosArgs.url
                };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Like a video
         * @param {string} authorization Bearer token for authentication
         * @param {LikeVideoRequest} likeVideoRequest Video ID and action to perform
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async likeVideo(authorization: string, likeVideoRequest: LikeVideoRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).likeVideo(authorization, likeVideoRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {
                    ...localVarAxiosArgs.options,
                    url: (configuration?.basePath || basePath) + localVarAxiosArgs.url
                };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Authenticate user and login
         * @param {LoginRequest} loginRequest User credentials
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async login(loginRequest: LoginRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginReply>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).login(loginRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Register a new user
         * @param {RegisterRequest} registerRequest User information for registration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async register(registerRequest: RegisterRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RegisterReply>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).register(registerRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Send a message
         * @param {string} authorization Bearer token for authentication
         * @param {SendMessageRequest} sendMessageRequest Message information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendMessage(authorization: string, sendMessageRequest: SendMessageRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).sendMessage(authorization, sendMessageRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {
                    ...localVarAxiosArgs.options,
                    url: (configuration?.basePath || basePath) + localVarAxiosArgs.url
                };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Update user profile
         * @param {string} authorization Bearer token for authentication
         * @param {string} [name]
         * @param {string} [bio]
         * @param {any} [avatar]
         * @param {any} [bg]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateProfile(authorization: string, name?: string, bio?: string, avatar?: any, bg?: any, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateProfileResponse>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).updateProfile(authorization, name, bio, avatar, bg, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {
                    ...localVarAxiosArgs.options,
                    url: (configuration?.basePath || basePath) + localVarAxiosArgs.url
                };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Upload a video
         * @param {string} authorization Bearer token for authentication
         * @param {string} [title]
         * @param {string} [description]
         * @param {string} [category]
         * @param {any} [video]
         * @param {any} [cover]
         * @param {Array<string>} [tags]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadVideo(authorization: string, title?: string, description?: string, category?: string, video?: any, cover?: any, tags?: Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).uploadVideo(authorization, title, description, category, video, cover, tags, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {
                    ...localVarAxiosArgs.options,
                    url: (configuration?.basePath || basePath) + localVarAxiosArgs.url
                };
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         *
         * @summary Create a comment
         * @param {string} authorization Bearer token for authentication
         * @param {CommentActionReq} commentActionReq Comment information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createComment(authorization: string, commentActionReq: CommentActionReq, options?: any): AxiosPromise<CommentActionReply> {
            return DefaultApiFp(configuration).createComment(authorization, commentActionReq, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Follow or unfollow a user
         * @param {string} authorization Bearer token for authentication
         * @param {FollowActionRequest} followActionRequest User ID and action to perform
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        followAction(authorization: string, followActionRequest: FollowActionRequest, options?: any): AxiosPromise<object> {
            return DefaultApiFp(configuration).followAction(authorization, followActionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get comments for a video
         * @param {CommentListReq} commentListReq Comment information
         * @param {string} [authorization] Bearer token for authentication
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getComments(commentListReq: CommentListReq, authorization?: string, options?: any): AxiosPromise<CommentListReply> {
            return DefaultApiFp(configuration).getComments(commentListReq, authorization, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get followers of a user
         * @param {GetFollowersRequest} getFollowersRequest User ID and action to perform
         * @param {string} [authorization] Bearer token for authentication
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFollowers(getFollowersRequest: GetFollowersRequest, authorization?: string, options?: any): AxiosPromise<GetFollowersReply> {
            return DefaultApiFp(configuration).getFollowers(getFollowersRequest, authorization, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get users followed by a user
         * @param {GetFollowingsRequest} getFollowingsRequest User ID and action to perform
         * @param {string} [authorization] Bearer token for authentication
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFollowing(getFollowingsRequest: GetFollowingsRequest, authorization?: string, options?: any): AxiosPromise<GetFollowingsReply> {
            return DefaultApiFp(configuration).getFollowing(getFollowingsRequest, authorization, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get friends of a user
         * @param {string} authorization Bearer token for authentication
         * @param {GetFriendsRequest} getFriendsRequest User ID and action to perform
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFriends(authorization: string, getFriendsRequest: GetFriendsRequest, options?: any): AxiosPromise<GetFriendsReply> {
            return DefaultApiFp(configuration).getFriends(authorization, getFriendsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get liked videos by user ID
         * @param {GetLikedVideosRequest} getLikedVideosRequest User ID and action to perform
         * @param {string} [authorization] Bearer token for authentication
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLikedVideos(getLikedVideosRequest: GetLikedVideosRequest, authorization?: string, options?: any): AxiosPromise<GetLikedVideosReply> {
            return DefaultApiFp(configuration).getLikedVideos(getLikedVideosRequest, authorization, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get messages
         * @param {string} authorization Bearer token for authentication
         * @param {GetMessagesRequest} getMessagesRequest Message information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessages(authorization: string, getMessagesRequest: GetMessagesRequest, options?: any): AxiosPromise<GetMessagesReply> {
            return DefaultApiFp(configuration).getMessages(authorization, getMessagesRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get recent videos by user ID
         * @param {GetRecentVideosRequest} getRecentVideosRequest User ID and action to perform
         * @param {string} [authorization] Bearer token for authentication
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecentVideos(getRecentVideosRequest: GetRecentVideosRequest, authorization?: string, options?: any): AxiosPromise<GetRecentVideosReply> {
            return DefaultApiFp(configuration).getRecentVideos(getRecentVideosRequest, authorization, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get user by ID
         * @param {string} userId ID of the user to retrieve
         * @param {string} authorization Bearer token for authentication
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(userId: string, authorization: string, options?: any): AxiosPromise<User> {
            return DefaultApiFp(configuration).getUser(userId, authorization, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get videos by user ID
         * @param {GetUserVideosRequest} getUserVideosRequest User ID and action to perform
         * @param {string} [authorization] Bearer token for authentication
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserVideos(getUserVideosRequest: GetUserVideosRequest, authorization?: string, options?: any): AxiosPromise<GetUserVideosReply> {
            return DefaultApiFp(configuration).getUserVideos(getUserVideosRequest, authorization, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get video by ID
         * @param {string} videoId ID of the video to retrieve
         * @param {string} [authorization] Bearer token for authentication
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVideo(videoId: string, authorization?: string, options?: any): AxiosPromise<GetVideoReply> {
            return DefaultApiFp(configuration).getVideo(videoId, authorization, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Like a video
         * @param {string} authorization Bearer token for authentication
         * @param {LikeVideoRequest} likeVideoRequest Video ID and action to perform
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        likeVideo(authorization: string, likeVideoRequest: LikeVideoRequest, options?: any): AxiosPromise<object> {
            return DefaultApiFp(configuration).likeVideo(authorization, likeVideoRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Authenticate user and login
         * @param {LoginRequest} loginRequest User credentials
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(loginRequest: LoginRequest, options?: any): AxiosPromise<LoginReply> {
            return DefaultApiFp(configuration).login(loginRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Register a new user
         * @param {RegisterRequest} registerRequest User information for registration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        register(registerRequest: RegisterRequest, options?: any): AxiosPromise<RegisterReply> {
            return DefaultApiFp(configuration).register(registerRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Send a message
         * @param {string} authorization Bearer token for authentication
         * @param {SendMessageRequest} sendMessageRequest Message information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendMessage(authorization: string, sendMessageRequest: SendMessageRequest, options?: any): AxiosPromise<object> {
            return DefaultApiFp(configuration).sendMessage(authorization, sendMessageRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Update user profile
         * @param {string} authorization Bearer token for authentication
         * @param {string} [name]
         * @param {string} [bio]
         * @param {any} [avatar]
         * @param {any} [bg]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProfile(authorization: string, name?: string, bio?: string, avatar?: any, bg?: any, options?: any): AxiosPromise<UpdateProfileResponse> {
            return DefaultApiFp(configuration).updateProfile(authorization, name, bio, avatar, bg, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Upload a video
         * @param {string} authorization Bearer token for authentication
         * @param {string} [title]
         * @param {string} [description]
         * @param {string} [category]
         * @param {any} [video]
         * @param {any} [cover]
         * @param {Array<string>} [tags]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadVideo(authorization: string, title?: string, description?: string, category?: string, video?: any, cover?: any, tags?: Array<string>, options?: any): AxiosPromise<object> {
            return DefaultApiFp(configuration).uploadVideo(authorization, title, description, category, video, cover, tags, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     *
     * @summary Create a comment
     * @param {string} authorization Bearer token for authentication
     * @param {CommentActionReq} commentActionReq Comment information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public createComment(authorization: string, commentActionReq: CommentActionReq, options?: any) {
        return DefaultApiFp(this.configuration).createComment(authorization, commentActionReq, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Follow or unfollow a user
     * @param {string} authorization Bearer token for authentication
     * @param {FollowActionRequest} followActionRequest User ID and action to perform
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public followAction(authorization: string, followActionRequest: FollowActionRequest, options?: any) {
        return DefaultApiFp(this.configuration).followAction(authorization, followActionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Get comments for a video
     * @param {CommentListReq} commentListReq Comment information
     * @param {string} [authorization] Bearer token for authentication
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getComments(commentListReq: CommentListReq, authorization?: string, options?: any) {
        return DefaultApiFp(this.configuration).getComments(commentListReq, authorization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Get followers of a user
     * @param {GetFollowersRequest} getFollowersRequest User ID and action to perform
     * @param {string} [authorization] Bearer token for authentication
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getFollowers(getFollowersRequest: GetFollowersRequest, authorization?: string, options?: any) {
        return DefaultApiFp(this.configuration).getFollowers(getFollowersRequest, authorization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Get users followed by a user
     * @param {GetFollowingsRequest} getFollowingsRequest User ID and action to perform
     * @param {string} [authorization] Bearer token for authentication
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getFollowing(getFollowingsRequest: GetFollowingsRequest, authorization?: string, options?: any) {
        return DefaultApiFp(this.configuration).getFollowing(getFollowingsRequest, authorization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Get friends of a user
     * @param {string} authorization Bearer token for authentication
     * @param {GetFriendsRequest} getFriendsRequest User ID and action to perform
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getFriends(authorization: string, getFriendsRequest: GetFriendsRequest, options?: any) {
        return DefaultApiFp(this.configuration).getFriends(authorization, getFriendsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Get liked videos by user ID
     * @param {GetLikedVideosRequest} getLikedVideosRequest User ID and action to perform
     * @param {string} [authorization] Bearer token for authentication
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getLikedVideos(getLikedVideosRequest: GetLikedVideosRequest, authorization?: string, options?: any) {
        return DefaultApiFp(this.configuration).getLikedVideos(getLikedVideosRequest, authorization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Get messages
     * @param {string} authorization Bearer token for authentication
     * @param {GetMessagesRequest} getMessagesRequest Message information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getMessages(authorization: string, getMessagesRequest: GetMessagesRequest, options?: any) {
        return DefaultApiFp(this.configuration).getMessages(authorization, getMessagesRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Get recent videos by user ID
     * @param {GetRecentVideosRequest} getRecentVideosRequest User ID and action to perform
     * @param {string} [authorization] Bearer token for authentication
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getRecentVideos(getRecentVideosRequest: GetRecentVideosRequest, authorization?: string, options?: any) {
        return DefaultApiFp(this.configuration).getRecentVideos(getRecentVideosRequest, authorization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Get user by ID
     * @param {string} userId ID of the user to retrieve
     * @param {string} authorization Bearer token for authentication
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getUser(userId: string, authorization: string, options?: any) {
        return DefaultApiFp(this.configuration).getUser(userId, authorization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Get videos by user ID
     * @param {GetUserVideosRequest} getUserVideosRequest User ID and action to perform
     * @param {string} [authorization] Bearer token for authentication
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getUserVideos(getUserVideosRequest: GetUserVideosRequest, authorization?: string, options?: any) {
        return DefaultApiFp(this.configuration).getUserVideos(getUserVideosRequest, authorization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Get video by ID
     * @param {string} videoId ID of the video to retrieve
     * @param {string} [authorization] Bearer token for authentication
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getVideo(videoId: string, authorization?: string, options?: any) {
        return DefaultApiFp(this.configuration).getVideo(videoId, authorization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Like a video
     * @param {string} authorization Bearer token for authentication
     * @param {LikeVideoRequest} likeVideoRequest Video ID and action to perform
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public likeVideo(authorization: string, likeVideoRequest: LikeVideoRequest, options?: any) {
        return DefaultApiFp(this.configuration).likeVideo(authorization, likeVideoRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Authenticate user and login
     * @param {LoginRequest} loginRequest User credentials
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public login(loginRequest: LoginRequest, options?: any) {
        return DefaultApiFp(this.configuration).login(loginRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Register a new user
     * @param {RegisterRequest} registerRequest User information for registration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public register(registerRequest: RegisterRequest, options?: any) {
        return DefaultApiFp(this.configuration).register(registerRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Send a message
     * @param {string} authorization Bearer token for authentication
     * @param {SendMessageRequest} sendMessageRequest Message information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public sendMessage(authorization: string, sendMessageRequest: SendMessageRequest, options?: any) {
        return DefaultApiFp(this.configuration).sendMessage(authorization, sendMessageRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Update user profile
     * @param {string} authorization Bearer token for authentication
     * @param {string} [name]
     * @param {string} [bio]
     * @param {any} [avatar]
     * @param {any} [bg]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public updateProfile(authorization: string, name?: string, bio?: string, avatar?: any, bg?: any, options?: any) {
        return DefaultApiFp(this.configuration).updateProfile(authorization, name, bio, avatar, bg, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Upload a video
     * @param {string} authorization Bearer token for authentication
     * @param {string} [title]
     * @param {string} [description]
     * @param {string} [category]
     * @param {any} [video]
     * @param {any} [cover]
     * @param {Array<string>} [tags]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public uploadVideo(authorization: string, title?: string, description?: string, category?: string, video?: any, cover?: any, tags?: Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).uploadVideo(authorization, title, description, category, video, cover, tags, options).then((request) => request(this.axios, this.basePath));
    }
}
